% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/derivs.R
\name{grad_ft}
\alias{grad_ft}
\alias{hess_ft}
\alias{DD}
\alias{gradf_t}
\alias{hessf_t}
\alias{grad_par}
\title{devirs of double logistics functions (analytical resolution)}
\usage{
grad_ft(FUN)

hess_ft(FUN)

DD(expr, name, order = 1)

gradf_t(FUN)

hessf_t(FUN)

grad_par(FUN)
}
\arguments{
\item{FUN}{Curve fitting function.}

\item{expr}{expression}

\item{par}{Named vector, or named list. It can't be matrix.
Colnamed matrix cooperating with plyr::alply will be fine.}
}
\value{
expression was returned.

return the gradient function of double logistics
}
\description{
Analytical derivative can also have some weird result. `numDeriv`'s result
was accurate enough.

For par aspect DERIVS, it had better to use deriv return function.
For t aspect DERIVS, it had better to use D, then eval D expression
}
\details{
Enclosure env of `ans` was this funcion's execution env. But environment of
C language based deriv function was wired.

grad is the first order derivative, and hess is the second order derivative.
`f` means function, generated from `deriv` function
`e` means expression, generated from `D` or `D` function

gradf_t   : gradient function f(par, t) (from the aspect of t)
hessf_t   : hessian  function f(par, t) (from the aspect of t)
grade_t   : gradient expression function f(par, t), get values through `eval`, (from the aspect of t)
hesse_t   : gradient expression function f(par, t), get values through `eval`, (from the aspect of t)

grad_fpar : gradient function f(par, t), get values through `eval`, (from the aspect of t)
hess_fpar : hessian  function f(par, t), get values through `eval`, (from the aspect of t)
}
\examples{
\dontrun{
# grade_t' only cost 3/4 time of 'gradf_t'
# hesse_t' used more 1/2 times of 'hessf_t'
microbenchmark(
    gradf_t(FUN)(par,t),
    grade_t(FUN)(par,t))
microbenchmark(
 hessf_t(FUN)(par,t),
 hesse_t(FUN)(par,t))
}
}
